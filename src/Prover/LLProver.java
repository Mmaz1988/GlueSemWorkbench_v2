package Prover;

import gluePaP.linearLogic.*;

import java.util.*;

public class LLProver {

    private List<Equality> equalities;

    /*
    Does a deduction of a given sequent by evaluating the list of premises on its LHS
    and trying to find a valid proof for its RHS.
    TODO Check if compilation works properly
     */
    public Premise deduce(Sequent seq) throws ProverException {
        /*
        Initialize an agenda stack initially containing all premises from the sequent.
        Premises are popped from the stack into the database and additionally created
        premises get pushed onto the stack.
        Then initialize a database of all premises which is used to look for possible
        implication elimination steps.
        */
        Stack<Premise> agenda = new Stack<>();
        List<Premise> database = new ArrayList<>();
        for (Premise p: seq.getLhs()) {

            /*
            * Check all premises for nested formulas. Alle nested formulas
            * (with two or more nested operators) are compiled following the algorithm
            * outlined by Hepple(1996). All extracted assumptions are added to the agenda
            * as new premises with new IDs.
            * */
            if (p.getTerm() instanceof LLFormula) {
                LLFormula f = ((LLFormula) p.getTerm());
                if (f.isNested()) {
                    // call the conversion method which does all the work
                    f = convert(f);
                    p.setTerm(f);
                    // add all assumptions generated by the conversion to the agenda
                    for (LLTerm term : f.assumptions) {
                        HashSet<Integer> newIDs= new HashSet<>();
                        newIDs.add(seq.getNewID());
                        Premise assumptionPremise = new Premise(newIDs,term);
                        agenda.push(assumptionPremise);
                    }
                    f.assumptions.clear();
                }
            }
            agenda.push(p);
        }

        /*
        Initialize the set containing the IDs of all premises of the sequent.
        This set is used to determine possible goal terms.
        */
        HashSet<Integer> goalIDs = seq.getMaxIDSet();

        /*
        The algorithm loops over the agenda until it is empty or until a premise is created
        that contains all indexes of the sequent's premises and is therefore the goal.
        */
        while (!agenda.empty()) {
            Premise curr_premise = agenda.pop();
            // add premise to database
            database.add(curr_premise);
            for (int i = 0; i < database.size(); i++) {
                Premise db_premise = database.get(i);

                if (db_premise == curr_premise)
                    continue;

                /*
                Check if the database term is a (complex) formula, if so try to do an
                implication elimination step with the current term on the agenda (curr_premise).
                If successful add the newly created Premise to the database.
                */
                if (db_premise.getTerm() instanceof LLFormula) {
                    if (!db_premise.getTerm().assumptions.isEmpty()) {

                    }
                    Premise new_premise = this.combinePremises(db_premise,curr_premise);
                    if (new_premise != null) {
                        if (new_premise.getPremiseIDs().equals(goalIDs)) {
                            return new_premise;
                        }
                        else {
                            agenda.push(new_premise);
                        }
                        continue;
                    }
                }
                /*
                Check if the current term on the agenda is a (complex) formula. If so do the same procedure
                as above, but reverse (apply db_premise to curr_premise).
                 */
                if (curr_premise.getTerm() instanceof LLFormula) {
                    Premise new_premise = this.combinePremises(curr_premise,db_premise);
                    if (new_premise != null) {
                        if (new_premise.getPremiseIDs().equals(goalIDs)) {
                            return new_premise;
                        }
                        else {
                            agenda.push(new_premise);
                        }
                    }

                }
            }
        }

        throw new ProverException("No valid proof found for premises");
    }


    /*
    implementation of the linear implication elimination rule for indexed premises
    check if arg is equivalent to LHS of func and then return RHS of func
    then check if the sets of indexes are disjoint
    if both checks succeed a new Premise is created containing the unified set of indexes
    and the RHS LL term of func (see below)
    */
    public Premise combinePremises(Premise func, Premise arg) {

        if (((LLFormula) func.getTerm()).getLhs().checkEquivalence(arg.getTerm())) {
            // TODO review this again
            /*
            * No assumptions or discharges involved, proceed with a "normal" implication elimination
            * */
            if (arg.getTerm().assumptions.isEmpty()
                    && arg.getTerm().discharges.isEmpty()
                    && func.getTerm().assumptions.isEmpty()
                    && func.getTerm().discharges.isEmpty()) {
                return combineDisjointID(func, arg);
            }
            // Functor has discharges, check if they are a subset of the arguments assumptions
            else if (!func.getTerm().discharges.isEmpty()) {
                if (arg.getTerm().assumptions.containsAll(func.getTerm().discharges))
                    return combineDisjointID(func, arg);
            }
            // Vice versa: argument has discharges, function has assumptions
            // TODO is this even realistic?
            else if (!arg.getTerm().discharges.isEmpty()) {
                if (func.getTerm().assumptions.containsAll(func.getTerm().discharges))
                    return combineDisjointID(func, arg);
            }
            return null;



            // There are assumptions and/or discharges involved.
/*            else {
                *//*
                There are discharges in the functor, only combine the premises when the
                set of the functor's discharges is a subset of the arguments assumptions.
                *//*
                if (!((LLFormula) func.getTerm()).getLhs().discharges.isEmpty()) {
                    if (((LLFormula) arg.getTerm()).getLhs().assumptions.
                            containsAll(func.getTerm().discharges)) {
                        return combineDisjointID(func, arg);
                    }
                    return null;
                }
                *//*
                * The argument has assumptions associated with it but the functor has no discharges.
                * Add the argument's assumptions to the functors assumptions (if it has any).
                * *//*
                else {
                    Premise combined = combineDisjointID(func, arg);
                    if (combined != null)
                        combined.getTerm().assumptions.addAll(arg.getTerm().assumptions);
                    return combined;
                }
            }*/
        }
        else if (func.getTerm() instanceof LLUniversalQuant) {

           if ( ((LLUniversalQuant) func.getTerm()).getTerm().getLhs().checkCompatibility(arg.getTerm()) != null )
           {
               List<Equality> equalitiesqualities =
               ((LLUniversalQuant) func.getTerm()).getTerm().getLhs().checkCompatibility(arg.getTerm());



           }


                return null;


        }
        else {
            return null;
        }

    }


    /*
    * Check if the LHS of func is equivalent to arg
    * and if the two sets of indexes associated with them are disjoint.
    * If so return the
    * */
    private Premise combineDisjointID(Premise func, Premise arg) {
        HashSet<Integer> combined_IDs = new HashSet<>();
        if (((LLFormula) func.getTerm()).getLhs().checkEquivalence(arg.getTerm())
                && Collections.disjoint(func.getPremiseIDs(),arg.getPremiseIDs())){
            combined_IDs.addAll(func.getPremiseIDs());
            combined_IDs.addAll(arg.getPremiseIDs());
            return new Premise(combined_IDs,((LLFormula) func.getTerm()).getRhs());
        }
        return null;
    }


    /*
    Similar to combinePremises(), but for simple LL terms
    implementation of the linear implication elimination rule for LL terms
    check if arg is equivalent to LHS of func and then return RHS of func
    e.g. func = a -o b; arg = a --> returns b
    */
    public LLTerm combineTerms(LLFormula func, LLTerm arg) {

        if (func.getLhs().checkEquivalence(arg)) {
            return func.getRhs();
        }
        else {
            return null;
        }
    }

    // wrapper method for later
    public LLFormula convert(LLFormula term) {
        return (LLFormula) convert((LLTerm) term);
    }

    // TODO add lists for modifiers and skeletons (see Dick's code)
    // TODO use premises instead of formulas?
    public LLTerm convert(LLTerm term) {
        if (term instanceof LLFormula) {
            LLFormula f = (LLFormula) term;

            // the formula is a modifer no need to convert it
            if (f.getLhs().checkEquivalence(f.getRhs()))
                return term;

            /*
            The LHS of the LHS of f will become an assumption which in turn gets converted as well.
            dependency is a new formula consisting of the rest of f, that is, the RHS of the LHS of f
            and the RHS of f. The assumption gets converted as well and is marked as an assumption
            with a boolean.
            All extracted assumptions are stored in a HashSet in dependency
            Ex. if f = ((a -o b) -o c) then dependency = (b -o c) and assumption = {a}
            */
            // TODO add semantic operations for conversion steps (i.e. lambda abstraction)
            if (f.getLhs() instanceof LLFormula &&
                    ((LLFormula) f.getLhs()).getOperator() instanceof LLImplication) {
                LLTerm assumption = convert(((LLFormula) f.getLhs()).getLhs());
                assumption.assumptions.add(assumption);
                LLTerm dependency = convert(new LLFormula(f.getTermId(),((LLFormula) f.getLhs()).getRhs(),
                        f.getOperator(),f.getRhs(),f.isPolarity()));
                ((LLFormula) dependency).assumptions.addAll(assumption.assumptions);
                ((LLFormula) dependency).discharges.addAll(assumption.assumptions);

                return dependency;
            }
        }
        return term;
    }

}
